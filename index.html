<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bibliotekarz Pixel â€” Zbieranie ksiÄ…Å¼ek</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; background:#070a12; font-family: system-ui, Arial; }
    .wrap { display:flex; min-height:100vh; align-items:center; justify-content:center; padding:18px; }
    .hud {
      width: min(980px, 96vw);
      display:flex; align-items:center; justify-content:space-between;
      color:#e8ecff; margin-bottom:10px; gap:10px; flex-wrap:wrap;
    }
    .pill{
      background:#0f1430; border:1px solid #22306a; border-radius:999px;
      padding:7px 11px; font-size:14px;
    }
    canvas{
      width: min(980px, 96vw);
      aspect-ratio: 16 / 10;
      image-rendering: pixelated;
      border-radius:18px;
      border:1px solid #22306a;
      background:#0b1026;
      box-shadow: 0 18px 55px rgba(0,0,0,.55);
      display:block;
    }
    button{
      cursor:pointer; border-radius:12px; border:1px solid #22306a;
      background:#0f1430; color:#e8ecff; padding:9px 11px;
    }
    button:hover{ filter:brightness(1.15); }
    .hint{ opacity:.85 }
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <div class="hud">
        <div class="pill"><b>KsiÄ…Å¼ki:</b> <span id="score">0</span>/<span id="total">0</span></div>
        <div class="pill"><b>Å»ycia:</b> <span id="lives">3</span></div>
        <div class="pill"><b>Czas:</b> <span id="time">0.0</span>s</div>
        <div class="pill hint">Sterowanie: <b>WASD</b> / strzaÅ‚ki â€¢ <b>Shift</b> sprint â€¢ <b>R</b> restart</div>
        <button id="restart">Restart</button>
      </div>
      <canvas id="game" width="960" height="600"></canvas>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const totalEl = document.getElementById("total");
  const timeEl  = document.getElementById("time");
  const livesEl = document.getElementById("lives");
  document.getElementById("restart").addEventListener("click", () => reset(true));

  // ======= Ustawienia Å›wiata (wiÄ™ksze i czytelniejsze) =======
  const TILE = 24;           // wiÄ™ksze kafelki
  const MAP_W = 40;          // 40 * 24 = 960
  const MAP_H = 25;          // 25 * 24 = 600

  // Tile types: 0 podÅ‚oga, 1 regaÅ‚/Å›ciana, 2 atrament (spowalnia)
  let map = [];
  let books = [];
  let inkPuddles = [];
  let totalBooks = 0;

  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d","r","shift"].includes(k)) e.preventDefault();
    keys.add(k);
    if (k === "r") reset(true);
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  const player = {
    x: 2*TILE,
    y: 2*TILE,
    w: 16,
    h: 18,
    baseSpeed: 130,       // px/s
    sprintBonus: 70,
    vx: 0,
    vy: 0,
    invulnUntil: 0        // ms
  };

  let guards = [];
  let score = 0;
  let lives = 3;
  let startTime = 0;
  let lastT = 0;
  let running = true;

  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  // ======= Mapa: biblioteka (regaÅ‚y jako labirynt) =======
  function buildMap() {
    map = Array.from({length: MAP_H}, () => Array(MAP_W).fill(0));

    // Ramka
    for (let x=0;x<MAP_W;x++){ map[0][x]=1; map[MAP_H-1][x]=1; }
    for (let y=0;y<MAP_H;y++){ map[y][0]=1; map[y][MAP_W-1]=1; }

    // DÅ‚ugie regaÅ‚y (pasy) + przejÅ›cia
    // UkÅ‚ad: kilka poziomych pasÃ³w z "przerwami" (korytarze)
    const bands = [4, 8, 12, 16, 20];
    for (const by of bands){
      for (let x=2; x<MAP_W-2; x++){
        // przerwy co jakiÅ› czas
        if (x % 9 === 0 || x % 13 === 0) continue;
        // gruboÅ›Ä‡ regaÅ‚u 2 kafelki
        map[by][x] = 1;
        if (by+1 < MAP_H-1) map[by+1][x] = 1;
      }
    }

    // Pionowe krÃ³tsze regaÅ‚y dla urozmaicenia
    for (let i=0;i<7;i++){
      const x = randInt(4, MAP_W-5);
      const y = randInt(2, MAP_H-8);
      const h = randInt(3,6);
      for (let yy=y; yy<y+h; yy++){
        if (yy % 7 === 0) continue;
        map[yy][x] = 1;
      }
    }

    // Dodaj kilka kaÅ‚uÅ¼ atramentu (2) na podÅ‚odze
    inkPuddles = [];
    const puddleCount = 10;
    let tries = 0;
    while (inkPuddles.length < puddleCount && tries < 5000){
      tries++;
      const tx = randInt(1, MAP_W-2);
      const ty = randInt(1, MAP_H-2);
      if (map[ty][tx] !== 0) continue;
      // nie przy starcie
      if (Math.abs(tx-2)+Math.abs(ty-2) < 6) continue;
      // nie duplikuj
      if (inkPuddles.some(p => p.tx===tx && p.ty===ty)) continue;

      map[ty][tx] = 2;
      inkPuddles.push({tx,ty});
    }
  }

  function findOpenTileFarFrom(px,py, minDist=10){
    for (let tries=0; tries<8000; tries++){
      const tx = randInt(1, MAP_W-2);
      const ty = randInt(1, MAP_H-2);
      if (map[ty][tx] === 1) continue;
      if (Math.abs(tx-px)+Math.abs(ty-py) < minDist) continue;
      return {tx,ty};
    }
    return {tx: 2, ty: 2};
  }

  function placeBooks() {
    books = [];
    score = 0;
    totalBooks = 14;
    totalEl.textContent = totalBooks;
    scoreEl.textContent = score;

    const px = Math.floor(player.x / TILE);
    const py = Math.floor(player.y / TILE);

    let tries = 0;
    while (books.length < totalBooks && tries < 8000){
      tries++;
      const tx = randInt(1, MAP_W-2);
      const ty = randInt(1, MAP_H-2);
      if (map[ty][tx] === 1) continue; // nie na regale
      if (Math.abs(tx - px) + Math.abs(ty - py) < 6) continue;
      if (books.some(b => b.tx===tx && b.ty===ty)) continue;
      // unikaj atramentu pod ksiÄ…Å¼kÄ…
      if (map[ty][tx] === 2) continue;

      books.push({ tx, ty, collected:false });
    }
  }

  function placeGuards(){
    guards = [];
    // 2 straÅ¼nikÃ³w
    for (let i=0;i<2;i++){
      const spawn = findOpenTileFarFrom(2,2, 18);
      guards.push({
        x: spawn.tx*TILE + 4,
        y: spawn.ty*TILE + 4,
        w: 16,
        h: 16,
        speed: 90 + i*15,
        dirX: (i%2===0 ? 1 : -1),
        dirY: 0,
        changeTimer: 0
      });
    }
  }

  function reset(restartTimer=false){
    buildMap();
    player.x = 2*TILE;
    player.y = 2*TILE;
    player.vx = 0; player.vy = 0;
    player.invulnUntil = 0;

    lives = 3;
    livesEl.textContent = lives;

    placeBooks();
    placeGuards();

    if (restartTimer){
      startTime = performance.now();
      lastT = startTime;
    }
    running = true;
  }

  // ======= Kolizje i ruch =======
  function tileAtPixel(px, py){
    const tx = Math.floor(px / TILE);
    const ty = Math.floor(py / TILE);
    if (tx < 0 || ty < 0 || tx >= MAP_W || ty >= MAP_H) return 1;
    return map[ty][tx];
  }
  function isWallAtPixel(px, py){ return tileAtPixel(px,py) === 1; }

  function moveRectWithCollision(obj, dt){
    const nextX = obj.x + obj.vx * dt;
    const nextY = obj.y + obj.vy * dt;

    // X
    let nx = nextX;
    if (obj.vx !== 0){
      const left = nx;
      const right = nx + obj.w;
      const top = obj.y;
      const bottom = obj.y + obj.h;

      const step = obj.vx > 0 ? right : left;
      if (isWallAtPixel(step, top) || isWallAtPixel(step, bottom)){
        const tx = Math.floor(step / TILE);
        if (obj.vx > 0) nx = tx*TILE - obj.w - 0.01;
        else nx = (tx+1)*TILE + 0.01;
      }
    }

    // Y
    let ny = nextY;
    if (obj.vy !== 0){
      const left = nx;
      const right = nx + obj.w;
      const top = ny;
      const bottom = ny + obj.h;

      const step = obj.vy > 0 ? bottom : top;
      if (isWallAtPixel(left, step) || isWallAtPixel(right, step)){
        const ty = Math.floor(step / TILE);
        if (obj.vy > 0) ny = ty*TILE - obj.h - 0.01;
        else ny = (ty+1)*TILE + 0.01;
      }
    }

    obj.x = nx;
    obj.y = ny;
  }

  function rectsOverlap(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  function updatePlayerVelocity(){
    let dx = 0, dy = 0;
    if (keys.has("w") || keys.has("arrowup")) dy -= 1;
    if (keys.has("s") || keys.has("arrowdown")) dy += 1;
    if (keys.has("a") || keys.has("arrowleft")) dx -= 1;
    if (keys.has("d") || keys.has("arrowright")) dx += 1;

    if (dx !== 0 || dy !== 0){
      const len = Math.hypot(dx,dy);
      dx /= len; dy /= len;
    }

    const sprint = keys.has("shift");
    let speed = player.baseSpeed + (sprint ? player.sprintBonus : 0);

    // atrament spowalnia (jeÅ›li Å›rodek postaci stoi na tile=2)
    const centerX = player.x + player.w/2;
    const centerY = player.y + player.h/2;
    const onInk = (tileAtPixel(centerX, centerY) === 2);
    if (onInk) speed *= 0.55;

    player.vx = dx * speed;
    player.vy = dy * speed;
  }

  function checkBookPickup(){
    for (const b of books){
      if (b.collected) continue;
      const bx = b.tx*TILE + 5;
      const by = b.ty*TILE + 5;
      const bw = 14, bh = 14;
      if (rectsOverlap(player.x,player.y,player.w,player.h, bx,by,bw,bh)){
        b.collected = true;
        score++;
        scoreEl.textContent = score;
        if (score >= totalBooks) running = false;
      }
    }
  }

  function respawnPlayer(){
    player.x = 2*TILE;
    player.y = 2*TILE;
    player.vx = 0; player.vy = 0;
    player.invulnUntil = performance.now() + 1200; // 1.2s nietykalnoÅ›ci
  }

function isWalkableTile(tx, ty){
  if (tx < 0 || ty < 0 || tx >= MAP_W || ty >= MAP_H) return false;
  return map[ty][tx] !== 1;
}

function hasLineOfSight(ax,ay,bx,by){
  // tylko linia prosta (korytarze)
  if (ax !== bx && ay !== by) return false;

  const dx = Math.sign(bx-ax);
  const dy = Math.sign(by-ay);
  let x = ax, y = ay;

  while (x !== bx || y !== by){
    if (map[y][x] === 1) return false;
    x += dx; y += dy;
  }
  return true;
}


  
  function updateGuards(dt){
  const px = Math.floor(player.x / TILE);
  const py = Math.floor(player.y / TILE);

  for (const g of guards){
    const gx = Math.floor(g.x / TILE);
    const gy = Math.floor(g.y / TILE);

    // --- AGRO: widzi gracza w korytarzu ---
    if (hasLineOfSight(gx,gy,px,py)){
      g.dirX = Math.sign(px - gx);
      g.dirY = Math.sign(py - gy);

      // tylko jedna oÅ›
      if (Math.abs(px-gx) > Math.abs(py-gy)){
        g.dirY = 0;
      } else {
        g.dirX = 0;
      }
    }
    // --- PATROL ---
    else if (Math.random() < 0.02){
      const dirs = [
        {x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}
      ];
      const valid = dirs.filter(d =>
        isWalkableTile(gx + d.x, gy + d.y)
      );
      if (valid.length){
        const d = valid[Math.floor(Math.random()*valid.length)];
        g.dirX = d.x;
        g.dirY = d.y;
      }
    }

    g.vx = g.dirX * g.speed;
    g.vy = g.dirY * g.speed;

    const beforeX = g.x, beforeY = g.y;
    moveRectWithCollision(g, dt);

    // --- jeÅ›li utknÄ…Å‚ â†’ natychmiast zmieÅ„ kierunek ---
    if (Math.abs(g.x - beforeX) < 0.01 && Math.abs(g.y - beforeY) < 0.01){
      const dirs = [
        {x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}
      ];
      const valid = dirs.filter(d =>
        isWalkableTile(gx + d.x, gy + d.y)
      );
      if (valid.length){
        const d = valid[Math.floor(Math.random()*valid.length)];
        g.dirX = d.x;
        g.dirY = d.y;
      }
    }
  }
}


  function checkGuardHits(){
    const now = performance.now();
    if (now < player.invulnUntil) return;

    for (const g of guards){
      if (rectsOverlap(player.x,player.y,player.w,player.h, g.x,g.y,g.w,g.h)){
        lives--;
        livesEl.textContent = lives;
        if (lives <= 0){
          running = false;
        } else {
          respawnPlayer();
        }
        return;
      }
    }
  }

  // ======= Tekstury: podÅ‚oga, regaÅ‚y, atrament =======
function drawFloor(px,py,x,y){
  // ciemna zieleÅ„ â€“ biblioteka
  ctx.fillStyle = "#0e2a1c";
  ctx.fillRect(px,py,TILE,TILE);

  // subtelna faktura
  ctx.fillStyle = ((x+y)&1) ? "#0c2418" : "#123422";
  ctx.fillRect(px+2,py+2,6,6);

  ctx.fillStyle = "rgba(255,255,255,0.04)";
  ctx.fillRect(px+14,py+5,7,2);
  ctx.fillRect(px+5,py+16,9,2);
}


  function drawShelf(px,py,x,y){
    // drewno
    ctx.fillStyle = "#3a2716";
    ctx.fillRect(px,py,TILE,TILE);

    // pÃ³Å‚ki
    ctx.fillStyle = "#2a1a10";
    ctx.fillRect(px,py+4,TILE,3);
    ctx.fillRect(px,py+12,TILE,3);
    ctx.fillRect(px,py+20,TILE,2);

    // ksiÄ…Å¼ki jako kolorowe "grzbiety"
    const colors = ["#c0392b","#f39c12","#27ae60","#2980b9","#8e44ad","#ecf0f1"];
    for (let i=0;i<4;i++){
      const bx = px + 3 + i*5;
      const by = py + 6 + ((x+y+i)&1);
      ctx.fillStyle = colors[(x + y + i) % colors.length];
      ctx.fillRect(bx, by, 3, 6);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(bx, by, 1, 6);
    }

    // obramowanie
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(px,py,TILE,2);
    ctx.fillRect(px,py,TILE?2:2,TILE);
  }

  function drawInk(px,py,x,y){
    drawFloor(px,py,x,y);
    // plama atramentu
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.beginPath();
    ctx.ellipse(px+12, py+14, 10, 7, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "rgba(120,160,255,0.12)";
    ctx.fillRect(px+6,py+12,10,2);
  }

  function drawBook(b){
    const x = b.tx*TILE;
    const y = b.ty*TILE;

    // cieÅ„
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(x+7, y+18, 12, 3);

    // okÅ‚adka
    ctx.fillStyle = "#f1c40f";
    ctx.fillRect(x+7,y+6,12,14);

    // grzbiet
    ctx.fillStyle = "#d35400";
    ctx.fillRect(x+7,y+6,3,14);

    // kartki
    ctx.fillStyle = "#fff3cf";
    ctx.fillRect(x+10,y+8,8,10);

    // pasek tytuÅ‚u
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(x+10,y+12,8,2);
  }

  function drawPlayer(){
    const now = performance.now();
    const blinking = now < player.invulnUntil && Math.floor(now/120)%2===0;
    if (blinking) return;

    const px = player.x, py = player.y;

    // cieÅ„
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(px+3, py+18, 12, 4);

    // nogi
    ctx.fillStyle = "#1abc9c";
    ctx.fillRect(px+3, py+14, 4, 6);
    ctx.fillRect(px+9, py+14, 4, 6);

    // ciaÅ‚o (sweter)
    ctx.fillStyle = "#2ecc71";
    ctx.fillRect(px+2, py+6, 12, 10);

    // gÅ‚owa
    ctx.fillStyle = "#f1c27d";
    ctx.fillRect(px+4, py, 8, 7);

    // wÅ‚osy
    ctx.fillStyle = "#2c2c2c";
    ctx.fillRect(px+4, py, 8, 2);

    // okulary (stereotyp bibliotekarza)
    ctx.fillStyle = "#0b0e14";
    ctx.fillRect(px+4, py+3, 3, 2);
    ctx.fillRect(px+9, py+3, 3, 2);
    ctx.fillRect(px+7, py+4, 2, 1); // mostek

    // uÅ›miech
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(px+7, py+6, 2, 1);

    // "teczka" / ksiÄ…Å¼ka pod pachÄ…
    ctx.fillStyle = "#f39c12";
    ctx.fillRect(px+13, py+9, 3, 6);
  }

  function drawGuard(g){
    // straÅ¼nik (czerwony bibliotekarz-ochroniarz)
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(g.x+2, g.y+14, 12, 4);

    ctx.fillStyle = "#e74c3c";
    ctx.fillRect(g.x+2, g.y+2, 12, 12);

    ctx.fillStyle = "#c0392b";
    ctx.fillRect(g.x+2, g.y+10, 12, 4);

    // oczy
    ctx.fillStyle = "#0b0e14";
    ctx.fillRect(g.x+5, g.y+6, 2, 2);
    ctx.fillRect(g.x+10, g.y+6, 2, 2);

    // gwizdek
    ctx.fillStyle = "#bdc3c7";
    ctx.fillRect(g.x+7, g.y+12, 3, 2);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // mapa
    for (let y=0;y<MAP_H;y++){
      for (let x=0;x<MAP_W;x++){
        const px = x*TILE, py = y*TILE;
        const t = map[y][x];
        if (t === 1) drawShelf(px,py,x,y);
        else if (t === 2) drawInk(px,py,x,y);
        else drawFloor(px,py,x,y);
      }
    }

    // ksiÄ…Å¼ki
    for (const b of books){
      if (!b.collected) drawBook(b);
    }

    // straÅ¼nicy
    for (const g of guards) drawGuard(g);

    // gracz
    drawPlayer();

    // overlay win/lose
    if (!running){
      ctx.fillStyle = "rgba(0,0,0,0.62)";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      ctx.fillStyle = "#e8ecff";
      ctx.font = "26px system-ui, Arial";
      const win = (score >= totalBooks);
      const text = win ? "Zebrane! Biblioteka uratowana ðŸ“š" : "Ciiiâ€¦ ZÅ‚apany! ðŸ¤«";
      ctx.fillText(text, 220, 270);

      ctx.font = "15px system-ui, Arial";
      ctx.fillText("NaciÅ›nij R albo kliknij Restart", 345, 305);
    }
  }

  function loop(t){
    if (!startTime) { startTime = t; lastT = t; }
    const dt = Math.min(0.033, (t - lastT) / 1000);
    lastT = t;

    if (running){
      updatePlayerVelocity();
      moveRectWithCollision(player, dt);
      checkBookPickup();

      updateGuards(dt);
      checkGuardHits();

      timeEl.textContent = ((t - startTime)/1000).toFixed(1);

      // jeÅ›li przegrana przez Å¼ycia
      if (lives <= 0) running = false;
    }

    draw();
    requestAnimationFrame(loop);
  }

  reset(true);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
