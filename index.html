<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bibliotekarz Pixel ‚Äî Arcade Library (stabilna wersja)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; background:#050906; font-family: system-ui, Arial; }
    .wrap { display:flex; min-height:100vh; align-items:center; justify-content:center; padding:18px; }
    .hud {
      width: min(1100px, 96vw);
      display:flex; align-items:center; justify-content:space-between;
      color:#eafff2; margin-bottom:10px; gap:10px; flex-wrap:wrap;
    }
    .pill{
      background:#0f2b1d; border:1px solid #1f5a3b; border-radius:999px;
      padding:7px 11px; font-size:14px;
    }
    canvas{
      width: min(1100px, 96vw);
      aspect-ratio: 16 / 10;
      image-rendering: pixelated;
      border-radius:18px;
      border:1px solid #1f5a3b;
      background:#0b2418;
      box-shadow:0 18px 55px rgba(0,0,0,.60);
      display:block;
    }
    button{
      cursor:pointer; border-radius:12px; border:1px solid #1f5a3b;
      background:#0f2b1d; color:#eafff2; padding:9px 11px;
    }
    button:hover{ filter:brightness(1.15); }
    .hint{ opacity:.9 }
  </style>
</head>
<body>
  <div class="wrap">
    <div>
      <div class="hud">
        <div class="pill"><b>üìö KsiƒÖ≈ºki:</b> <span id="score">0</span>/<span id="total">0</span></div>
        <div class="pill"><b>‚ù§Ô∏è ≈ªycia:</b> <span id="lives">3</span></div>
        <div class="pill"><b>‚è± Czas:</b> <span id="time">0.0</span>s</div>
        <div class="pill hint">WASD / strza≈Çki ‚Ä¢ Shift sprint ‚Ä¢ R restart ‚Ä¢ P pauza</div>
        <button id="restart">Restart</button>
      </div>
      <canvas id="game" width="960" height="600"></canvas>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const totalEl = document.getElementById("total");
  const livesEl = document.getElementById("lives");
  const timeEl  = document.getElementById("time");
  document.getElementById("restart").addEventListener("click", () => reset(true));

  const TILE = 24;
  const MAP_W = 40; // 960
  const MAP_H = 25; // 600

  const T_FLOOR = 0, T_SHELF = 1, T_INK = 2, T_TABLE = 3;

  const BOOK_COUNT = 16;
  const START_LIVES = 3;

  let map = [];
  let books = [];
  let guards = [];
  let particles = [];

  let score = 0;
  let lives = START_LIVES;
  let startTime = 0;
  let lastT = 0;
  let running = true;
  let paused = false;

  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    if (["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d","r","shift","p"].includes(k)) e.preventDefault();
    keys.add(k);
    if (k === "r") reset(true);
    if (k === "p") paused = !paused;
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function now(){ return performance.now(); }

  function rectsOverlap(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  const player = {
    x: 2*TILE,
    y: 2*TILE,
    w: 16,
    h: 18,
    baseSpeed: 160,
    sprintBonus: 80,
    vx: 0,
    vy: 0,
    invulnUntil: 0
  };

  // ===== Map helpers =====
  function tileAt(tx,ty){
    if (tx<0 || ty<0 || tx>=MAP_W || ty>=MAP_H) return T_SHELF;
    return map[ty][tx];
  }
  function tileAtPixel(px,py){
    return tileAt(Math.floor(px/TILE), Math.floor(py/TILE));
  }
  function blocksMovement(t){
    return t === T_SHELF || t === T_TABLE;
  }
  function blocksVision(t){
    return t === T_SHELF; // sto≈Çy nie blokujƒÖ wzroku
  }
  function isBlockedAtPixel(px,py){
    return blocksMovement(tileAtPixel(px,py));
  }
  function isWalkableTile(tx,ty){
    return !blocksMovement(tileAt(tx,ty));
  }

  function moveWithCollision(entity, dt){
    const nextX = entity.x + entity.vx * dt;
    const nextY = entity.y + entity.vy * dt;

    // X
    let nx = nextX;
    if (entity.vx !== 0){
      const left   = nx;
      const right  = nx + entity.w;
      const top    = entity.y;
      const bottom = entity.y + entity.h;

      const stepX = entity.vx > 0 ? right : left;
      if (isBlockedAtPixel(stepX, top) || isBlockedAtPixel(stepX, bottom)){
        const tx = Math.floor(stepX / TILE);
        if (entity.vx > 0) nx = tx*TILE - entity.w - 0.01;
        else nx = (tx+1)*TILE + 0.01;
      }
    }

    // Y
    let ny = nextY;
    if (entity.vy !== 0){
      const left   = nx;
      const right  = nx + entity.w;
      const top    = ny;
      const bottom = ny + entity.h;

      const stepY = entity.vy > 0 ? bottom : top;
      if (isBlockedAtPixel(left, stepY) || isBlockedAtPixel(right, stepY)){
        const ty = Math.floor(stepY / TILE);
        if (entity.vy > 0) ny = ty*TILE - entity.h - 0.01;
        else ny = (ty+1)*TILE + 0.01;
      }
    }

    entity.x = nx;
    entity.y = ny;
  }

  function playerOnInk(){
    const cx = player.x + player.w/2;
    const cy = player.y + player.h/2;
    return tileAtPixel(cx,cy) === T_INK;
  }

  // ==========================================================
  //  Generator mapy: baza = POD≈ÅOGA, przeszkody = rega≈Çy/sto≈Çy/atrament
  //  + BFS walidacja (brak softlock√≥w)
  // ==========================================================

  function makeEmptyMap(){
    map = Array.from({length: MAP_H}, () => Array(MAP_W).fill(T_FLOOR));

    // ramka rega≈Ç√≥w
    for (let x=0;x<MAP_W;x++){ map[0][x]=T_SHELF; map[MAP_H-1][x]=T_SHELF; }
    for (let y=0;y<MAP_H;y++){ map[y][0]=T_SHELF; map[y][MAP_W-1]=T_SHELF; }

    // start zawsze czysty
    for (let y=1;y<=5;y++) for (let x=1;x<=5;x++) map[y][x]=T_FLOOR;
  }

  function placeShelves(){
    // d≈Çugie pasy rega≈Ç√≥w z przerwami
    const bands = [5, 9, 13, 17, 21];
    for (const by of bands){
      for (let x=2; x<MAP_W-2; x++){
        if (x % 10 === 0 || x % 14 === 0) continue;
        map[by][x] = T_SHELF;
        if (by+1 < MAP_H-1) map[by+1][x] = T_SHELF;
      }
    }

    // pionowe kr√≥tsze rega≈Çy
    for (let i=0;i<10;i++){
      const x = randInt(4, MAP_W-5);
      const y = randInt(2, MAP_H-9);
      const h = randInt(4,8);
      for (let yy=y; yy<y+h; yy++){
        if ((yy+i) % 6 === 0) continue; // dziury
        map[yy][x] = T_SHELF;
      }
    }

    // trzy "czytelnie" (czyste obszary)
    for (let i=0;i<3;i++){
      const w = randInt(9, 14);
      const h = randInt(6, 9);
      const x = randInt(2, MAP_W - w - 3);
      const y = randInt(2, MAP_H - h - 3);
      for (let yy=y; yy<y+h; yy++){
        for (let xx=x; xx<x+w; xx++){
          if (xx<=0 || yy<=0 || xx>=MAP_W-1 || yy>=MAP_H-1) continue;
          map[yy][xx] = T_FLOOR;
        }
      }
    }

    // nie blokuj startu
    for (let y=1;y<=5;y++) for (let x=1;x<=5;x++) map[y][x]=T_FLOOR;
  }

  function placeTables(count){
    let placed = 0, tries = 0;
    while (placed < count && tries < 20000){
      tries++;
      const tx = randInt(2, MAP_W-3);
      const ty = randInt(2, MAP_H-3);
      if (map[ty][tx] !== T_FLOOR) continue;
      if (Math.abs(tx-2)+Math.abs(ty-2) < 7) continue;

      const floorAround =
        (map[ty-1][tx]===T_FLOOR) + (map[ty+1][tx]===T_FLOOR) + (map[ty][tx-1]===T_FLOOR) + (map[ty][tx+1]===T_FLOOR);
      if (floorAround <= 1) continue;

      map[ty][tx] = T_TABLE;
      placed++;
    }
  }

  function placeInk(count){
    let placed = 0, tries = 0;
    while (placed < count && tries < 25000){
      tries++;
      const tx = randInt(2, MAP_W-3);
      const ty = randInt(2, MAP_H-3);
      if (map[ty][tx] !== T_FLOOR) continue;
      if (Math.abs(tx-2)+Math.abs(ty-2) < 9) continue;

      const walls =
        (map[ty-1][tx]===T_SHELF) + (map[ty+1][tx]===T_SHELF) + (map[ty][tx-1]===T_SHELF) + (map[ty][tx+1]===T_SHELF);
      if (walls < 2 && Math.random() < 0.75) continue;

      map[ty][tx] = T_INK;
      placed++;
    }
  }

  function randomFloorTileFarFrom(tx0,ty0, minManhattan){
    for (let tries=0; tries<20000; tries++){
      const tx = randInt(1, MAP_W-2);
      const ty = randInt(1, MAP_H-2);
      if (map[ty][tx] !== T_FLOOR) continue;
      const d = Math.abs(tx-tx0)+Math.abs(ty-ty0);
      if (d < minManhattan) continue;
      return {tx,ty};
    }
    return {tx:2,ty:2};
  }

  function placeBooks(){
    books = [];
    score = 0;

    let tries = 0;
    while (books.length < BOOK_COUNT && tries < 50000){
      tries++;
      const tx = randInt(1, MAP_W-2);
      const ty = randInt(1, MAP_H-2);
      if (map[ty][tx] !== T_FLOOR) continue;
      if (Math.abs(tx-2)+Math.abs(ty-2) < 7) continue;
      if (books.some(b => b.tx===tx && b.ty===ty)) continue;
      books.push({tx,ty,collected:false,bob:Math.random()*Math.PI*2});
    }

    totalEl.textContent = BOOK_COUNT;
    scoreEl.textContent = score;
  }

  // BFS: ile kafelk√≥w floor/ink/table jest osiƒÖgalnych z (2,2)?
  // (ink i floor sƒÖ chodliwe, table jest blokadƒÖ ruchu)
  function computeReachable(){
    const q = [];
    const seen = Array.from({length: MAP_H}, () => Array(MAP_W).fill(false));
    q.push({x:2,y:2});
    seen[2][2] = true;

    while(q.length){
      const n = q.shift();
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      for (const [dx,dy] of dirs){
        const nx = n.x + dx, ny = n.y + dy;
        if (nx<0||ny<0||nx>=MAP_W||ny>=MAP_H) continue;
        if (seen[ny][nx]) continue;
        if (!isWalkableTile(nx,ny)) continue;
        seen[ny][nx] = true;
        q.push({x:nx,y:ny});
      }
    }
    return seen;
  }

  function validateNoSoftlock(){
    const seen = computeReachable();
    // wszystkie ksiƒÖ≈ºki muszƒÖ byƒá reachable
    for (const b of books){
      if (!seen[b.ty][b.tx]) return false;
    }
    // start musi byƒá chodliwy
    return isWalkableTile(2,2);
  }

  function generateLibrarySafe(){
    // losuj a≈º bƒôdzie przej≈õciowe (max 50 pr√≥b)
    for (let attempt=0; attempt<50; attempt++){
      makeEmptyMap();
      placeShelves();
      placeTables(16);
      placeInk(18);
      placeBooks();

      if (validateNoSoftlock()){
        return true;
      }
    }
    return false;
  }

  // ==========================================================
  //  Wrogowie (3 typy) + AI bez blokowania
  // ==========================================================

  function hasLineOfSight(ax,ay,bx,by){
    if (ax !== bx && ay !== by) return false;
    const dx = Math.sign(bx-ax);
    const dy = Math.sign(by-ay);
    let x = ax, y = ay;
    while (x !== bx || y !== by){
      if (!(x===ax && y===ay)){
        if (blocksVision(tileAt(x,y))) return false;
      }
      x += dx; y += dy;
    }
    return true;
  }

  function chooseNewDirection(g){
    const gx = Math.floor(g.x / TILE);
    const gy = Math.floor(g.y / TILE);
    const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
    const back = {dx:-g.dirX, dy:-g.dirY};

    const candidates = dirs
      .filter(d => isWalkableTile(gx+d.dx, gy+d.dy))
      .map(d => {
        let s = 0;
        const isBack = (d.dx===back.dx && d.dy===back.dy);
        const isStraight = (d.dx===g.dirX && d.dy===g.dirY);
        if (isStraight) s += 2.0;
        if (isBack) s -= (g.stuckFrames > 6 ? 0.2 : 3.0);
        s += Math.random()*1.25;
        return {d, s};
      })
      .sort((a,b)=>b.s-a.s);

    if (candidates.length){
      g.dirX = candidates[0].d.dx;
      g.dirY = candidates[0].d.dy;
    } else {
      g.dirX = back.dx || 1;
      g.dirY = back.dy || 0;
    }
  }

  function placeGuards(){
    guards = [];

    const configs = [
      {type:"normal", speed:125, turniness:0.06, sight:10},
      {type:"fast",   speed:170, turniness:0.08, sight:9},
      {type:"scout",  speed:115, turniness:0.05, sight:14},
    ];

    for (let i=0;i<6;i++){
      const cfg = configs[i % configs.length];
      const spawn = randomFloorTileFarFrom(2,2, 16);
      guards.push({
        x: spawn.tx*TILE + 4,
        y: spawn.ty*TILE + 4,
        w: 16,
        h: 16,
        vx: 0, vy: 0,
        speed: cfg.speed,
        type: cfg.type,
        turniness: cfg.turniness,
        sight: cfg.sight,
        dirX: Math.random()<0.5 ? 1 : -1,
        dirY: 0,
        stuckFrames: 0,
        alertUntil: 0
      });
    }
  }

  function updateGuards(dt){
    const px = Math.floor(player.x / TILE);
    const py = Math.floor(player.y / TILE);

    for (const g of guards){
      const gx = Math.floor(g.x / TILE);
      const gy = Math.floor(g.y / TILE);

      const dist = Math.abs(px-gx) + Math.abs(py-gy);
      const canSee = dist <= g.sight && hasLineOfSight(gx,gy,px,py);
      if (canSee) g.alertUntil = now() + 900;

      const alerted = now() < g.alertUntil;

      if (alerted){
        const dx = px - gx;
        const dy = py - gy;
        if (Math.abs(dx) > Math.abs(dy)){
          g.dirX = Math.sign(dx) || g.dirX;
          g.dirY = 0;
        } else {
          g.dirY = Math.sign(dy) || g.dirY;
          g.dirX = 0;
        }
        const boost = (g.type==="fast") ? 1.12 : (g.type==="scout" ? 1.05 : 1.08);
        g.vx = g.dirX * g.speed * boost;
        g.vy = g.dirY * g.speed * boost;
      } else {
        if (Math.random() < g.turniness) chooseNewDirection(g);
        g.vx = g.dirX * g.speed;
        g.vy = g.dirY * g.speed;
      }

      const bx = g.x, by = g.y;
      moveWithCollision(g, dt);

      const moved = Math.abs(g.x-bx) + Math.abs(g.y-by);
      if (moved < 0.02){
        g.stuckFrames++;
        chooseNewDirection(g);
      } else {
        g.stuckFrames = Math.max(0, g.stuckFrames-1);
      }
    }
  }

  // ==========================================================
  //  Gameplay: ksiƒÖ≈ºki, trafienia, respawn, particles
  // ==========================================================

  function spawnParticles(x,y, kind){
    const n = (kind==="book") ? 14 : 18;
    for (let i=0;i<n;i++){
      particles.push({
        x, y,
        vx: (Math.random()*2-1) * (kind==="hit" ? 90 : 70),
        vy: (Math.random()*2-1) * (kind==="hit" ? 90 : 70),
        life: 0.45 + Math.random()*0.35,
        kind
      });
    }
  }

  function updateParticles(dt){
    particles = particles.filter(p => {
      p.life -= dt;
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.vx *= (1 - 2.2*dt);
      p.vy *= (1 - 2.2*dt);
      return p.life > 0;
    });
  }

  function checkBookPickup(){
    for (const b of books){
      if (b.collected) continue;
      const bx = b.tx*TILE + 5;
      const by = b.ty*TILE + 5;
      if (rectsOverlap(player.x,player.y,player.w,player.h, bx,by,14,14)){
        b.collected = true;
        score++;
        scoreEl.textContent = score;
        spawnParticles(bx+7, by+7, "book");
        if (score >= BOOK_COUNT) running = false;
      }
    }
  }

  function respawnPlayer(){
    player.x = 2*TILE;
    player.y = 2*TILE;
    player.vx = player.vy = 0;
    player.invulnUntil = now() + 1200;
  }

  function checkGuardHits(){
    if (now() < player.invulnUntil) return;
    for (const g of guards){
      if (rectsOverlap(player.x,player.y,player.w,player.h, g.x,g.y,g.w,g.h)){
        lives--;
        livesEl.textContent = lives;
        spawnParticles(player.x + player.w/2, player.y + player.h/2, "hit");
        if (lives <= 0) running = false;
        else respawnPlayer();
        return;
      }
    }
  }

  // ==========================================================
  //  Player update
  // ==========================================================

  function updatePlayer(dt){
    let dx = 0, dy = 0;
    if (keys.has("w") || keys.has("arrowup")) dy -= 1;
    if (keys.has("s") || keys.has("arrowdown")) dy += 1;
    if (keys.has("a") || keys.has("arrowleft")) dx -= 1;
    if (keys.has("d") || keys.has("arrowright")) dx += 1;

    if (dx !== 0 || dy !== 0){
      const len = Math.hypot(dx,dy);
      dx /= len; dy /= len;
    }

    const sprint = keys.has("shift");
    let speed = player.baseSpeed + (sprint ? player.sprintBonus : 0);
    if (playerOnInk()) speed *= 0.55;

    player.vx = dx * speed;
    player.vy = dy * speed;

    moveWithCollision(player, dt);
  }

  // ==========================================================
  //  Render (teksturowanie)
  // ==========================================================

  function drawFloor(px,py,x,y){
    ctx.fillStyle = "#0e2a1c";
    ctx.fillRect(px,py,TILE,TILE);

    ctx.fillStyle = ((x+y)&1) ? "#0b2317" : "#123422";
    ctx.fillRect(px+2,py+2,6,6);

    ctx.fillStyle = "rgba(255,255,255,0.05)";
    ctx.fillRect(px+14,py+5,7,2);
    ctx.fillRect(px+5,py+16,9,2);

    ctx.fillStyle = "rgba(0,0,0,0.10)";
    ctx.fillRect(px,py,TILE,1);
    ctx.fillRect(px,py,1,TILE);
  }

  function drawShelf(px,py,x,y){
    ctx.fillStyle = "#3a2716";
    ctx.fillRect(px,py,TILE,TILE);

    ctx.fillStyle = "#2a1a10";
    ctx.fillRect(px,py+4,TILE,3);
    ctx.fillRect(px,py+12,TILE,3);
    ctx.fillRect(px,py+20,TILE,2);

    const colors = ["#c0392b","#f39c12","#27ae60","#2980b9","#8e44ad","#ecf0f1"];
    for (let i=0;i<4;i++){
      const bx = px + 3 + i*5;
      const by = py + 6 + ((x+y+i)&1);
      ctx.fillStyle = colors[(x + y + i*2) % colors.length];
      ctx.fillRect(bx, by, 3, 6);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(bx, by, 1, 6);
    }

    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(px,py,TILE,2);
    ctx.fillRect(px,py,2,TILE);
  }

  function drawTable(px,py){
    ctx.fillStyle = "#5c3b1f";
    ctx.fillRect(px+2, py+6, TILE-4, TILE-10);
    ctx.fillStyle = "#3b2615";
    ctx.fillRect(px+4, py+16, 3, 6);
    ctx.fillRect(px+TILE-7, py+16, 3, 6);

    ctx.fillStyle = "#f7f1d5";
    ctx.fillRect(px+6, py+8, 8, 6);
    ctx.fillStyle = "rgba(0,0,0,0.12)";
    ctx.fillRect(px+6, py+11, 8, 1);

    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(px+2, py+TILE-3, TILE-4, 2);
  }

  function drawInk(px,py,x,y){
    drawFloor(px,py,x,y);
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.beginPath();
    ctx.ellipse(px+12, py+14, 10, 7, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "rgba(150,210,170,0.12)";
    ctx.fillRect(px+6, py+12, 10, 2);
  }

  function drawBook(b){
    const x = b.tx*TILE;
    const y = b.ty*TILE;
    b.bob += 0.08;
    const bob = Math.sin(b.bob) * 1.2;

    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(x+7, y+19, 12, 3);

    ctx.fillStyle = "#f1c40f";
    ctx.fillRect(x+7, y+6 + bob, 12, 14);

    ctx.fillStyle = "#d35400";
    ctx.fillRect(x+7, y+6 + bob, 3, 14);

    ctx.fillStyle = "#fff3cf";
    ctx.fillRect(x+10, y+8 + bob, 8, 10);

    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect(x+10, y+12 + bob, 8, 2);
  }

  function drawPlayer(){
    const blinking = now() < player.invulnUntil && Math.floor(now()/120)%2===0;
    if (blinking) return;

    const px = player.x, py = player.y;
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(px+3, py+18, 12, 4);

    ctx.fillStyle = "#1abc9c";
    ctx.fillRect(px+3, py+14, 4, 6);
    ctx.fillRect(px+9, py+14, 4, 6);

    ctx.fillStyle = "#2ecc71";
    ctx.fillRect(px+2, py+6, 12, 10);

    ctx.fillStyle = "#f1c27d";
    ctx.fillRect(px+4, py, 8, 7);

    ctx.fillStyle = "#2c2c2c";
    ctx.fillRect(px+4, py, 8, 2);

    ctx.fillStyle = "#0b0e14";
    ctx.fillRect(px+4, py+3, 3, 2);
    ctx.fillRect(px+9, py+3, 3, 2);
    ctx.fillRect(px+7, py+4, 2, 1);

    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(px+7, py+6, 2, 1);

    ctx.fillStyle = "#f39c12";
    ctx.fillRect(px+13, py+9, 3, 7);
    ctx.fillStyle = "rgba(0,0,0,0.22)";
    ctx.fillRect(px+13, py+12, 3, 1);
  }

  function drawGuard(g){
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(g.x+2, g.y+14, 12, 4);

    let body = "#e74c3c", accent="#c0392b";
    if (g.type === "fast"){ body="#ff6b6b"; accent="#c44545"; }
    if (g.type === "scout"){ body="#9b59b6"; accent="#7e3f97"; }

    ctx.fillStyle = body;
    ctx.fillRect(g.x+2, g.y+2, 12, 12);

    ctx.fillStyle = accent;
    ctx.fillRect(g.x+2, g.y+10, 12, 4);

    ctx.fillStyle = "#0b0e14";
    ctx.fillRect(g.x+5, g.y+6, 2, 2);
    ctx.fillRect(g.x+10, g.y+6, 2, 2);

    if (now() < g.alertUntil){
      ctx.fillStyle = "#f1c40f";
      ctx.fillRect(g.x+13, g.y+1, 2, 2);
    }
  }

  function drawParticles(){
    for (const p of particles){
      const a = clamp(p.life / 0.8, 0, 1);
      ctx.fillStyle = (p.kind==="book")
        ? `rgba(241,196,15,${0.65*a})`
        : `rgba(255,110,110,${0.55*a})`;
      ctx.fillRect(p.x, p.y, 2, 2);
    }
  }

  function drawWorld(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    for (let y=0; y<MAP_H; y++){
      for (let x=0; x<MAP_W; x++){
        const px = x*TILE, py = y*TILE;
        const t = map[y][x];
        if (t === T_SHELF) drawShelf(px,py,x,y);
        else if (t === T_INK) drawInk(px,py,x,y);
        else {
          drawFloor(px,py,x,y);
          if (t === T_TABLE) drawTable(px,py);
        }
      }
    }

    for (const b of books) if (!b.collected) drawBook(b);
    for (const g of guards) drawGuard(g);
    drawPlayer();
    drawParticles();

    if (paused){
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "#eafff2";
      ctx.font = "24px system-ui, Arial";
      ctx.fillText("PAUZA", 430, 290);
      ctx.font = "14px system-ui, Arial";
      ctx.fillText("Naci≈õnij P, ≈ºeby wr√≥ciƒá", 385, 320);
    }

    if (!running){
      ctx.fillStyle = "rgba(0,0,0,0.62)";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      const win = (score >= BOOK_COUNT);
      ctx.fillStyle = "#eafff2";
      ctx.font = "26px system-ui, Arial";
      ctx.fillText(win ? "Zebrane! Biblioteka uratowana üìö" : "Ciii‚Ä¶ Z≈Çapany! ü§´", 200, 280);
      ctx.font = "15px system-ui, Arial";
      ctx.fillText("Naci≈õnij R albo kliknij Restart", 350, 315);
    }
  }

  // ==========================================================
  //  Reset / loop
  // ==========================================================

  function reset(restartTimer=false){
    // generator gwarantuje brak softlocka
    const ok = generateLibrarySafe();
    if (!ok){
      // awaryjnie: czysta mapa pod≈Çogi
      makeEmptyMap();
      placeBooks();
    }

    player.x = 2*TILE;
    player.y = 2*TILE;
    player.vx = player.vy = 0;
    player.invulnUntil = 0;

    lives = START_LIVES;
    livesEl.textContent = lives;

    placeGuards();
    particles = [];

    if (restartTimer){
      startTime = now();
      lastT = startTime;
      timeEl.textContent = "0.0";
    }

    paused = false;
    running = true;
  }
  window.reset = reset; // ≈ºeby dzia≈Ça≈Ç przycisk inline, jakby≈õ go kiedy≈õ u≈ºy≈Ç

  function loop(t){
    if (!startTime){ startTime = t; lastT = t; }
    const dt = Math.min(0.033, (t - lastT) / 1000);
    lastT = t;

    if (running && !paused){
      updatePlayer(dt);
      updateGuards(dt);
      checkBookPickup();
      checkGuardHits();
      updateParticles(dt);
      timeEl.textContent = ((t - startTime)/1000).toFixed(1);
      if (lives <= 0) running = false;
    } else {
      updateParticles(dt * 0.6);
    }

    drawWorld();
    requestAnimationFrame(loop);
  }

  reset(true);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
